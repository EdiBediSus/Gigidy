<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giggity.io - Multiplayer Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            background: #f0f0f0;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            pointer-events: all;
        }

        #startScreen h1 {
            font-size: 60px;
            color: #667eea;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        #startScreen .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
        }

        input {
            padding: 15px;
            font-size: 18px;
            border: 2px solid #667eea;
            border-radius: 10px;
            width: 300px;
            margin-bottom: 15px;
            outline: none;
        }

        #playButton {
            padding: 15px 60px;
            font-size: 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #playButton:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 16px;
            color: #333;
        }

        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            min-width: 200px;
        }

        #leaderboard h3 {
            margin-bottom: 10px;
            color: #667eea;
            text-align: center;
        }

        .leaderboard-item {
            padding: 5px 0;
            font-size: 14px;
        }

        #connectionStatus {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .connected {
            color: green;
        }

        .disconnected {
            color: red;
        }

        .connecting {
            color: orange;
        }

        #deathScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            color: white;
            display: none;
            pointer-events: all;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 250px;
        }

        #instructions h4 {
            color: #667eea;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="startScreen">
            <h1>üéÆ GIGGITY.IO</h1>
            <div class="subtitle">Eat food, avoid bigger players, dominate!</div>
            
            <input type="text" id="nameInput" placeholder="Enter your name" maxlength="15" value="Quagmire">
            
            <br><br>
            <button id="playButton">PLAY NOW!</button>
            <div style="margin-top: 20px; font-size: 12px; color: #999;">
                üéØ Use WASD or Arrow Keys to move ‚Ä¢ Eat food to grow
            </div>
        </div>

        <div id="deathScreen">
            <h2>üíÄ YOU DIED!</h2>
            <p id="deathMessage" style="margin: 20px 0; font-size: 18px;"></p>
            <button id="respawnButton" style="padding: 15px 40px; font-size: 18px; background: white; color: #667eea; border: none; border-radius: 10px; cursor: pointer;">
                RESPAWN
            </button>
        </div>

        <div id="stats" style="display: none;">
            <div><strong>Score:</strong> <span id="score">0</span></div>
            <div><strong>Players:</strong> <span id="playerCount">1</span></div>
        </div>

        <div id="leaderboard" style="display: none;">
            <h3>üèÜ Leaderboard</h3>
            <div id="leaderboardList"></div>
        </div>

        <div id="instructions" style="display: none;">
            <h4>üìñ Controls</h4>
            <div>‚Ä¢ <strong>W/‚Üë</strong> - Move up</div>
            <div>‚Ä¢ <strong>A/‚Üê</strong> - Move left</div>
            <div>‚Ä¢ <strong>S/‚Üì</strong> - Move down</div>
            <div>‚Ä¢ <strong>D/‚Üí</strong> - Move right</div>
            <div style="margin-top: 10px;">Eat dots and smaller players!</div>
        </div>

        <div id="connectionStatus">
            <span class="disconnected">‚ö´ Not Connected</span>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION - YOUR RENDER URL
        // ============================================
        const WEBSOCKET_URL = 'wss://gigidy.onrender.com';
        // ============================================

        // ============================================
        // DEFAULT CHARACTER IMAGE (optional)
        // ============================================
        const DEFAULT_CHARACTER_IMAGE = 'images.jfif';
        // Paste your image URL here to replace the Quagmire face
        // Example: 'https://username.github.io/giggity-io/character.png'
        // Leave empty '' to use the default Quagmire face
        // ============================================

        // Game Configuration
        const CONFIG = {
            WORLD_WIDTH: 3000,
            WORLD_HEIGHT: 3000,
            PLAYER_START_SIZE: 20,
            FOOD_SIZE: 5,
            FOOD_COUNT: 100,
            SPEED_MULTIPLIER: 3,
        };

        // Game state
        let canvas, ctx;
        let gameStarted = false;
        let ws = null;
        
        let player = {
            id: null,
            x: 0,
            y: 0,
            size: CONFIG.PLAYER_START_SIZE,
            name: '',
            score: 0,
            color: '#FF6B6B',
            imageUrl: null,
            image: null,
            velocityX: 0,
            velocityY: 0
        };

        let otherPlayers = new Map();
        let playerImages = new Map();
        let food = [];
        let camera = { x: 0, y: 0, zoom: 1 };
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;

        // Keyboard controls
        let keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            ArrowUp: false,
            ArrowLeft: false,
            ArrowDown: false,
            ArrowRight: false
        };

        // Initialize
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    e.preventDefault();
                }
            });

            document.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                    e.preventDefault();
                }
            });

            document.getElementById('playButton').addEventListener('click', startGame);
            document.getElementById('respawnButton').addEventListener('click', respawn);
            document.getElementById('nameInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') startGame();
            });

            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                if (!url) {
                    resolve(null);
                    return;
                }
                
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.warn('Failed to load image:', url);
                    resolve(null);
                };
                img.src = url;
            });
        }

        async function startGame() {
            const name = document.getElementById('nameInput').value.trim() || 'Quagmire';
            
            player.name = name;
            player.color = getRandomColor();
            player.imageUrl = DEFAULT_CHARACTER_IMAGE;
            
            // Load custom image if provided
            if (DEFAULT_CHARACTER_IMAGE) {
                player.image = await loadImage(DEFAULT_CHARACTER_IMAGE);
                if (player.image) {
                    console.log('Custom character image loaded!');
                }
            }
            
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('stats').style.display = 'block';
            document.getElementById('leaderboard').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            
            gameStarted = true;
            connectWebSocket();
        }

        function respawn() {
            document.getElementById('deathScreen').style.display = 'none';
            player.score = 0;
            player.size = CONFIG.PLAYER_START_SIZE;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'respawn' }));
            }
        }

        function connectWebSocket() {
            try {
                updateConnectionStatus('connecting');
                ws = new WebSocket(WEBSOCKET_URL);
                
                ws.onopen = () => {
                    console.log('Connected to server');
                    updateConnectionStatus('connected');
                    reconnectAttempts = 0;
                    
                    ws.send(JSON.stringify({
                        type: 'join',
                        name: player.name,
                        color: player.color,
                        imageUrl: player.imageUrl
                    }));
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected');
                };

                ws.onclose = () => {
                    console.log('Disconnected from server');
                    updateConnectionStatus('disconnected');
                    
                    if (gameStarted && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        setTimeout(() => {
                            console.log(`Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`);
                            connectWebSocket();
                        }, 3000);
                    }
                };
            } catch (error) {
                console.error('Failed to connect:', error);
                alert('Failed to connect to server. Please check your connection.');
            }
        }

        async function handleServerMessage(data) {
            switch (data.type) {
                case 'init':
                    player.id = data.id;
                    player.x = data.x;
                    player.y = data.y;
                    break;
                    
                case 'gameState':
                    otherPlayers.clear();
                    for (const p of data.players) {
                        if (p.id !== player.id) {
                            otherPlayers.set(p.id, p);
                            
                            if (p.imageUrl && !playerImages.has(p.id)) {
                                loadImage(p.imageUrl).then(img => {
                                    if (img) playerImages.set(p.id, img);
                                });
                            }
                        } else {
                            player.x = p.x;
                            player.y = p.y;
                            player.size = p.size;
                            player.score = p.score;
                        }
                    }
                    
                    food = data.food;
                    document.getElementById('playerCount').textContent = data.players.length;
                    updateLeaderboard(data.players);
                    break;

                case 'death':
                    showDeathScreen(data.killedBy);
                    break;
            }
        }

        function showDeathScreen(killerName) {
            const deathScreen = document.getElementById('deathScreen');
            const deathMessage = document.getElementById('deathMessage');
            
            deathMessage.textContent = `You were eaten by ${killerName}!`;
            deathScreen.style.display = 'block';
            
            setTimeout(() => {
                if (deathScreen.style.display === 'block') {
                    respawn();
                }
            }, 3000);
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            if (status === 'connected') {
                statusEl.innerHTML = '<span class="connected">üü¢ Connected</span>';
            } else if (status === 'connecting') {
                statusEl.innerHTML = '<span class="connecting">üü° Connecting...</span>';
            } else {
                statusEl.innerHTML = '<span class="disconnected">üî¥ Disconnected</span>';
            }
        }

        function updateLeaderboard(players) {
            const sorted = [...players].sort((a, b) => b.score - a.score).slice(0, 10);
            const list = document.getElementById('leaderboardList');
            
            list.innerHTML = sorted.map((p, i) => {
                const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
                const isMe = p.id === player.id ? ' <strong>(You)</strong>' : '';
                return `<div class="leaderboard-item">${medal} ${p.name}: ${p.score}${isMe}</div>`;
            }).join('');
        }

        // Movement update - only send when keys are pressed
        let lastMoveSent = 0;
        const moveThrottle = 150; // Send updates less frequently to reduce lag

        function gameLoop(timestamp) {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (!gameStarted) return;

            // Calculate movement from WASD/Arrow keys
            let moveX = 0;
            let moveY = 0;

            if (keys.w || keys.ArrowUp) moveY -= 1;
            if (keys.s || keys.ArrowDown) moveY += 1;
            if (keys.a || keys.ArrowLeft) moveX -= 1;
            if (keys.d || keys.ArrowRight) moveX += 1;

            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                const length = Math.sqrt(moveX * moveX + moveY * moveY);
                moveX /= length;
                moveY /= length;
            }

            // Send position to server (throttled)
            const now = Date.now();
            if (ws && ws.readyState === WebSocket.OPEN && now - lastMoveSent > moveThrottle) {
                // Calculate target position based on key input
                const speed = 500; // How far ahead to target
                const targetX = player.x + (moveX * speed);
                const targetY = player.y + (moveY * speed);
                
                ws.send(JSON.stringify({
                    type: 'move',
                    targetX: targetX,
                    targetY: targetY
                }));
                
                lastMoveSent = now;
            }

            // Update camera
            camera.x = player.x;
            camera.y = player.y;
            camera.zoom = Math.max(0.5, 1 - player.size / 300);

            document.getElementById('score').textContent = player.score;
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            
            // Apply camera
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            // Draw grid
            drawGrid();

            // Draw food
            food.forEach(f => {
                ctx.fillStyle = f.color;
                ctx.beginPath();
                ctx.arc(f.x, f.y, CONFIG.FOOD_SIZE, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw other players
            otherPlayers.forEach(p => {
                const img = playerImages.get(p.id);
                drawPlayer(p, img);
            });

            // Draw player
            if (gameStarted) {
                drawPlayer(player, player.image);
            }

            ctx.restore();
        }

        function drawGrid() {
            const gridSize = 50;
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;

            const startX = Math.floor((camera.x - canvas.width / 2 / camera.zoom) / gridSize) * gridSize;
            const endX = Math.ceil((camera.x + canvas.width / 2 / camera.zoom) / gridSize) * gridSize;
            const startY = Math.floor((camera.y - canvas.height / 2 / camera.zoom) / gridSize) * gridSize;
            const endY = Math.ceil((camera.y + canvas.height / 2 / camera.zoom) / gridSize) * gridSize;

            for (let x = startX; x <= endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }

            for (let y = startY; y <= endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        }

        function drawPlayer(p, customImage) {
            // Draw circle
            ctx.fillStyle = p.color;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Draw custom image or default face
            if (customImage) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.clip();
                
                const imgSize = p.size * 2;
                ctx.drawImage(customImage, p.x - p.size, p.y - p.size, imgSize, imgSize);
                ctx.restore();
            } else {
                // Draw Quagmire face
                const faceScale = p.size / 40;
                
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(p.x - p.size * 0.25, p.y - p.size * 0.15, p.size * 0.15, 0, Math.PI * 2);
                ctx.arc(p.x + p.size * 0.25, p.y - p.size * 0.15, p.size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(p.x - p.size * 0.25, p.y - p.size * 0.15, p.size * 0.08, 0, Math.PI * 2);
                ctx.arc(p.x + p.size * 0.25, p.y - p.size * 0.15, p.size * 0.08, 0, Math.PI * 2);
                ctx.fill();

                // Smile
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2 * faceScale;
                ctx.beginPath();
                ctx.arc(p.x, p.y + p.size * 0.1, p.size * 0.4, 0.2, Math.PI - 0.2);
                ctx.stroke();

                // Chin
                ctx.fillStyle = p.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(p.x, p.y + p.size * 0.6, p.size * 0.2, p.size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Draw name
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.font = `bold ${Math.max(12, p.size / 3)}px Arial`;
            ctx.textAlign = 'center';
            ctx.strokeText(p.name, p.x, p.y - p.size - 15);
            ctx.fillText(p.name, p.x, p.y - p.size - 15);
        }

        function getRandomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Start the game
        init();
    </script>
</body>
</html>
